## VS-Balancer

### Описание

Сервис vs-balancer (далее - балансер) выполняет функцию http прокси, проксируя таким образом, что при повторном запросе клиент будет направлен на тот хост, который был выбран при самом первом запросе. 

Например: есть несколько сервисов recorder запущенных на трех машинах - 192.168.0.1:1556, 192.168.0.2:1556, 192.168.0.3:1556. Этот список передается в настройки балансера. Клиенту же рекордера передается адрес балансера, и клиент в свою очередь обращается к балансеру при последующих запросах так, как если бы он обращался напрямую к рекордеру. Клиент не знает что это адрес балансера.

Клиент осуществляет запрос на запись архива по адресу POST /cameras/c3b761ca-b900-4f80-ba1b-a635f24ffa2a, где c3b761ca-b900-4f80-ba1b-a635f24ffa2a является уникальным идентификатор вновь создаваемой камеры. Балансер при помощи настроек выделяет из этого адреса c3b761ca-b900-4f80-ba1b-a635f24ffa2a и использует в качестве уникального идентификатора запроса привязывая к такому идентификатору выбранный адрес сервиса рекордера. 

Например, если при первичном обращении на запись камеры балансер выбрал машину с рекордером по адресу 192.168.0.2:1556 - то при последующих обращениях балансеров будет выбрана именно эта машина. Таким образом балансер осуществляет горизонтальное масштабирование рекордера без необходимости объединения записанных данных между ними.

Адреса выбираются циклически, равномерно распределяя нагрузку между инстансами(хостами) проксируемого сервиса.

### Порядок работы

#### Конфигурация

Балансер конфигурируется посредствам конфигурационного файла, значения которого могут быть изменены, в том числе через переменных окружения.

Пример конфигурационного файла:

```json
{
  "port": 1558,
  "maxBacklog": 128,
  "redirects": [
    {
      "name": "recorder",
      "targets": ["localhost:2000", "localhost:2001"],
      "type": "mem-uri",
      "templates": [
        "/cameras/$/info",
        "/cameras/$/ranges"
      ]
    },
    {
      "name": "recorderdb",
      "targets": ["localhost:2000", "localhost:2001"],
      "type": "postgresql-uri",
      "templates": [
        "/cameras/$/info",
        "/cameras/$/ranges"
      ]
    }
  ],
  "postgresql": [
    {
      "redirectName": "recorderdb",
      "connectionString": "postgresql://postgres:postgres@localhost/vs-balancer",
      "tableName": "rec_loadf"
    }
  ]
}
```

Переменные окружения:

- VS_BALANCER_PORT - TCP порт сервиса. **Значение по умолчанию: 1558.**
- VS_BALANCER_<имя редиректа из массива redirects>_TARGETS - список хостов на которые проксируются запросы. Например: VS_BALANCER_recorder_TARGETS="localhost:1, localhost:2"
- VS_BALANCER_<имя редиректа из массива postgresql>_PGCONN - строка соединения с базой данных. Например: VS_BALANCER_recorderdb_PGCONN="postgresql://postgres:postgres@localhost/vs-balancer"

#### Переменные файла конфигурации

- port, maxBacklog - порт и максимальное количество одновременно прослушиваемых соединений на порту.
- redirects - список редиректов
  - name - url-safe уникальное имя редиректа, которое в последствии используется в url 
  - targets - список хостов и их портов назначения, того на какие хосты нужно сделать редирект
  - type - тип работы редиректа
    - `mem-uri` - динамический редирект - то есть уникальность выбора конечной точки(targets) сохраняется до перезапуска балансера. Подходит только для stateless сервисов, то есть сервисов, которые не сохраняют свое состояние или же запросы к ним не зависят от сохраненного состояния.
    - `postgresql-uri` - статический редирект - то есть уникальность конечной точки(targets) сохраняется в базе postgresql и после перезапуска балансера конечная точка назначения для того же запроса будет сохранена.
  - templates - шаблоны по которым балансер выделяет уникальные части в урле при обращении к нему клиента. В шаблоне используются специальные символы: $ - означает что в этом месте урла содержится его уникальная часть, * - означает, что от части, где находится символ и до конца урла данные пропускаются, _ - означает, что пропускается только данная часть урла.
  - Пример шаблонов:
    - `/cameras/$/info`
    - `/cameras/$/*`
    - `/cameras/_/_/$/xxxx`
    
    При написании шаблона необходимо учитывать, что шаблон должен строго соответствовать урл в запросе, если не используется *, и при этом каждый шаблон должен содержать хотя бы один символ $ - указатель на уникальную часть урла.
- postgresql - список коннектов для редиректов типа `postgresql-uri`
  - redirectName - имя редиректа из вышеуказанного списка redirects 
  - connectionString - строка соединения с базой данных 
  - tableName - имя таблицы для сохранения записи о хосте для последующего редиректа на него

#### Пример конфигурирования для stateful сервиса

Например, есть сервис recorder при работе с которым используются следующее API:

- POST /cameras/<camera_id> - добавление камеры на запись
- GET /cameras/<camera_id>/info - получение информации по камере
- GET /cameras/<camera_id>/ranges - получение границ архива
- GET /<camera_id>?from=1625653110&to=1625653310&format=mp4 - выгрузка архива
- (RTSP) /<camera_id>?from=1625653110 - проигрывание архива rtsp

Так как recorder зависит от своего состояния, то-есть обратиться с одной и той де камерой к разным рекордера будет ошибкой, то необходимо подготовить следующий конфигурационный файл балансера:

```json
{
  "port": 1558,
  "maxBacklog": 128,
  "redirects": [
    {
      "name": "recorder",
      "targets": ["192.168.1.1:1556", "192.168.1.2:1556"],
      "type": "postgresql-uri",
      "templates": [
        "/$",
        "/cameras/$",
        "/cameras/$/info",
        "/cameras/$/ranges"
      ]
    }
  ],
  "postgresql": [
    {
      "redirectName": "recorder",
      "connectionString": "postgresql://postgres:postgres@localhost/vs-balancer",
      "tableName": "rec_loadf"
    }
  ]
}
```
Согласно вышеуказанному конфигурационному файлу, мы разместили рекордеры на машинах 192.168.1.1:1556 и 192.168.1.2:1556. И балансер например размещен на машине 192.168.1.3:1558, то при все последующие обращения клиента к рекордеру будут идти на 192.168.1.3:1558, и API изменится следующим образом:

- POST /recorder/cameras/<camera_id> - добавление камеры на запись
- GET /recorder/cameras/<camera_id>/info - получение информации по камере
- GET /recorder/cameras/<camera_id>/ranges - получение границ архива
- GET /recorder/<camera_id>?from=1625653110&to=1625653310&format=mp4 - выгрузка архива
- (RTSP) /recorder/<camera_id>?from=1625653110 - проигрывание архива rtsp

#### Пример конфигурирования для stateless сервиса

Если сервис не нуждается в сохранении своего состояния, как например видео proxy сервис, то можно сконфигурировать несколько инстансов такого сервиса с типом балансера `mem-uri` и отсутствующей секцией postgresql. Например:

```json
{
  "port": 1558,
  "maxBacklog": 128,
  "redirects": [
    {
      "name": "video-proxy",
      "targets": ["192.168.1.1:1554", "192.168.1.2:1554", "192.168.1.3:1554", "192.168.1.4:1554"],
      "type": "mem-uri",
      "templates": [
        "/$",
        "/xxx/$",
        "/xxx/$/yyy",
        "/xxx/$/zzz"
      ]
    }
  ]
}
```

API обращения к video-proxy изменится аналогичным образом:

- GET /video-proxy/<camera_id>
- GET /video-proxy/xxx/<camera_id>
- GET /video-proxy/xxx/<camera_id>/yyy
- GET /video-proxy/xxx/<camera_id>/zzz

